title: So Many Layers! A Note of Caution.
author: Harry
image: slice_of_sagittarius.jpg
image_credit: https://www.nasa.gov/image-feature/goddard/2017/hubbles-slice-of-sagittarius

In the book we are at pains to point out that each pattern is a trade-off, and
comes with costs.  But just on the offchance that anyone was still missing the
message, and thinking we were saying that all apps should be built like this,
I thought I'd write a small blog post just to reinforce the message about
costs. Each time you add a layer, you buy yourself some decoupling, but it
comes at the cost of an extra moving part.  In the simplest terms, there's an
extra file you have to maintain.


<a href="https://www.cosmicpython.com/book/appendix_ds1_table.html">
<figure>
  <img src="/book/images/apwp_aa01.png" alt="a recap of all the layers + parts of our architecture" max-height="60%">
  <figcaption>Here's a recap of all the layers + parts of our architecture</figcaption>
</figure>
</a>

I remember having to make a simple change to an app that the buying team at
MADE uses. We needed to record an extra piece of information for each shipment,
an optional "delay" field to be used in some ETA calculations.  This is a nice
illustration of a trip all the way through the stack, because things have to
change all the way from the frontend/UI, all the way down to the database.

If you're using a framework like Django, you might be used to thinking of a
change like this, in a perfect world, as a change you can make to just **one** file.
We change `models.py`, and then our `ModelForm` will be updated automatically,
and maybe even the frontend, if we're using the form's autogenerated HTML, will
"just work" too.  That's one of the reasons that Django is so good as a rapid
application development framework; by closely coupling its various parts, it
saves you a lot of messing about with database tables, html forms, validation,
and so on. And if those are the main things you spend your time on, then Django
is going to save you a lot of time.

But in our world (at least in theory [*](#in_theory)),
database tables and html forms are not where we spend our time.  Instead, we
optimise for making it as easy as possible to capture and understand business
logic, and as a result we want to _decouple_ things.

What does it cost?  Well, let's take a trip through each file I had to change,
when I was making my _very minor_ change to the data model in our app.

* I started off with editing a selenium test of the frontend, plus a javascript
  frontend test, plus the frontend javascript itself, plus an html template.
  That's four files already, but they're not strictly relevant to the patterns
  and layers whose cost I want to account for, so I'm going to say they don't
  count.  Don't worry; there's plenty more to come.

So:

1. An **end-to-end / API test** for the create and edit commands for the objects in question.
2. The **Command classes** that capture various [write interactions](https://www.cosmicpython.com/book/chapter_10_commands.html) a user can have
   with this model.
3. The **command schema** which we use to [validate incoming requests](https://www.cosmicpython.com/book/appendix_validation.html).
4. The **service-layer tests** which instantiate those commands to test their
   handlers
5. The **handlers at the service-layer** that orchestrate these use cases.
6. The **domain model tests** that were affected. Although [not every domain model
   needs low-level unit tests as well as service-layer tests](https://www.cosmicpython.com/book/chapter_05_high_gear_low_gear.html), so if I was being indulgent I might
   not count this.
7. The **Domain Model** itself.
8. The **Repository integration test**
https://www.cosmicpython.com/book/chapter_02_repository.html
9. The **Repository and ORM config** https://www.cosmicpython.com/book/chapter_02_repository.html
10. The **database schema**
11. A **migration file** (admittedly autogenerated by Alembic, but we like to just give them a bit of a tidy-up before committing).
12. The **Event classes** that capture ongoing internal/external consequences
    of the various affected use cases
13. The **Event schema** files we use for (outbound) validation.
14. And that's not all!  Because this app uses CQRS, the read-side is separate from the
write side, so I also had to change some **API JSON view tests**
15. And the **CQRS JSON views code**

So that's fifteen files.  Fifteen!

Now I should add that each change was very simple.  Most were a matter of
copy-pasting a line and some find+replace.  The whole job might have taken an hour
or so.  But if you're used to this sort of thing taking five minutes and happening
in a single file, or at most a couple, then when first confronted with all these
layers, you are definitely going to start questioning the sanity of the entire
endeavour.  I know I certainly did.

We think the cost we impose on ourselves here is worth it, because we believe
that the main thing we want to make easy is not adding database fields and html
forms.  We want to make it easy to capture complex and evolving business
requirements in a [domain model](https://www.cosmicpython.com/book/chapter_01_domain_model.html).  But, as we try to say in each chapter,
your mileage may vary!

<div id="#in_theory"><small><i>
  OK, in theory.  In practice I think this particular app was a _little_
  overengineered. It was one of the first ones that the team had complete
  freedom to try new patterns on, and they may have gone to town a little...
  But on the other hand, there is talk of converting that app to eventsourcing,
  and if we _had_ used Django, I don't think that would even be on the table,
  so...
</i></small></div>
